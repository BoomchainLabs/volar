{
  "version": 1.1,
  "tags": [
    {
      "name": "Transition",
      "description": {
        "kind": "markdown",
        "value": "\nОбеспечивает эффекты анимированного перехода **одного** элемента или компонента.\n\n- **Входные параметры**\n\n  ```ts\n  interface TransitionProps {\n    /**\n     * Используется для автоматической генерации CSS-классов перехода.\n     * Например, `name: 'fade'` автоматически раскроется в `.fade-enter`,\n     * `.fade-enter-active` и т.д.\n     */\n    name?: string\n    /**\n     * Применять ли СSS-классы переходов.\n     * По умолчанию: true\n     */\n    css?: boolean\n    /**\n     * Указывает тип событий перехода, которые необходимо ждать \n     * для определения момента окончания перехода.\n     * По умолчанию автоматически выбирается тип с большей длительностью.\n     */\n    type?: 'transition' | 'animation'\n    /**\n     * Определяет длительность перехода.\n     * По умолчанию Vue ждёт первого события `transitionend`\n     * или `animationend` на корневом элементе.\n     */\n    duration?: number | { enter: number; leave: number }\n    /**\n     * Управляет последовательностью переходов исчезновения/появления.\n     * По умолчанию — одновременно.\n     */\n    mode?: 'in-out' | 'out-in' | 'default'\n    /**\n     * Применять ли переход при первоначальном рендере.\n     * По умолчанию: false\n     */\n    appear?: boolean\n\n    /**\n     * Параметры для настройки классов перехода.\n     * Используйте kebab-case в шаблонах, например enter-from-class=\"xxx\"\n     */\n    enterFromClass?: string\n    enterActiveClass?: string\n    enterToClass?: string\n    appearFromClass?: string\n    appearActiveClass?: string\n    appearToClass?: string\n    leaveFromClass?: string\n    leaveActiveClass?: string\n    leaveToClass?: string\n  }\n  ```\n\n- **События**\n\n  - `@before-enter`\n  - `@before-leave`\n  - `@enter`\n  - `@leave`\n  - `@appear`\n  - `@after-enter`\n  - `@after-leave`\n  - `@after-appear`\n  - `@enter-cancelled`\n  - `@leave-cancelled` (только для `v-show`)\n  - `@appear-cancelled`\n\n- **Пример**\n\n  Простой элемент:\n\n  ```html\n  <Transition>\n    <div v-if=\"ok\">переключаемое содержимое</div>\n  </Transition>\n  ```\n\n  Принудительный эффект перехода путем изменения атрибута `key`:\n\n  ```html\n  <Transition>\n    <div :key=\"text\">{{ text }}</div>\n  </Transition>\n  ```\n\n  Динамический компонент, используются параметры mode и appear:\n\n  ```html\n  <Transition name=\"fade\" mode=\"out-in\" appear>\n    <component :is=\"view\"></component>\n  </Transition>\n  ```\n\n  Прослушивание событий перехода:\n\n  ```html\n  <Transition @after-enter=\"onTransitionComplete\">\n    <div v-show=\"ok\">переключаемое содержимое</div>\n  </Transition>\n  ```\n\n- **См. также** [Руководство — Transition](https://ru.vuejs.org/guide/built-ins/transition.html)\n"
      },
      "attributes": [],
      "references": "api/built-in-components.html#transition"
    },
    {
      "name": "TransitionGroup",
      "description": {
        "kind": "markdown",
        "value": "\nОбеспечивает эффекты перехода для **нескольких** элементов или компонентов в списке.\n\n- **Входные параметры**\n\n  `<TransitionGroup>` принимает те же параметры, что и `<Transition>`, за исключением `mode`, плюс два дополнительных параметра:\n\n  ```ts\n  interface TransitionGroupProps extends Omit<TransitionProps, 'mode'> {\n    /*\n     * Если не определен, то рендерится как fragment.\n     */\n    tag?: string\n    /**\n     * Для переопределения CSS-класса, применяемого во время анимаций перемещения.\n     * Используйте kebab-case в шаблонах, например move-class=\"xxx\"\n     */\n    moveClass?: string\n  }\n  ```\n\n- **События**\n\n  `<TransitionGroup>` генерирует те же события, что и `<Transition>`.\n\n- **Подробности**\n\n  По умолчанию `<TransitionGroup>` не создаёт DOM-элемент, но его можно задать с помощью параметра `tag`.\n\n  Обратите внимание, что у каждого потомка `<transition-group>` должен быть [**уникальный ключ**](https://ru.vuejs.org/guide/essentials/list.html#maintaining-state-with-key) для правильной работы анимаций.\n\n  `<TransitionGroup>` поддерживает анимации перемещения с помощью CSS трансформаций. Если положение потомка на экране изменится после обновления, ему будет добавлен CSS-класс (автоматически сгенерированный из атрибута `name` или заданный параметром `move-class`). Если после применения этого класса CSS-свойство `transform` возможно анимировать, элемент будет плавно перемещён в новое положение с помощью [техники FLIP](https://aerotwist.com/blog/flip-your-animations/).\n\n- **Пример**\n\n  ```html\n  <TransitionGroup tag=\"ul\" name=\"slide\">\n    <li v-for=\"item in items\" :key=\"item.id\">\n      {{ item.text }}\n    </li>\n  </TransitionGroup>\n  ```\n\n- **См. также** [Руководство — TransitionGroup](https://ru.vuejs.org/guide/built-ins/transition-group.html)\n"
      },
      "attributes": [],
      "references": "api/built-in-components.html#transitiongroup"
    },
    {
      "name": "KeepAlive",
      "description": {
        "kind": "markdown",
        "value": "\nКэширует содержащиеся внутри динамически переключаемые компоненты.\n\n- **Входные параметры**\n\n  ```ts\n  interface KeepAliveProps {\n    /**\n     * Если определено, то только компоненты с подходящими под\n     * `include` именами будут кэшированы.\n     */\n    include?: MatchPattern\n    /**\n     * Любой компонент с именем подходящим под `exclude`\n     * не будет кэшироваться.\n     */\n    exclude?: MatchPattern\n    /**\n     * Максимальное количество кэшируемых экземпляров компонентов.\n     */\n    max?: number | string\n  }\n\n  type MatchPattern = string | RegExp | (string | RegExp)[]\n  ```\n\n- **Подробности**\n\n  При оборачивании вокруг динамического компонента, `<KeepAlive>` кэширует неактивные экземпляры компонентов, не уничтожая их.\n\n  В любой момент времени в качестве прямого потомка `<KeepAlive>` может быть только один активный экземпляр компонента.\n\n  При переключении компонента внутри `<KeepAlive>` будут вызываться его хуки жизненного цикла `activated` и `deactivated` соответственно, предоставляя альтернативу хукам `mounted` и `unmounted`, которые не вызываются. Это относится как к непосредственному потомку `<KeepAlive>`, так и ко всем прочим его потомкам.\n\n- **Пример**\n\n  Базовое использование:\n\n  ```html\n  <KeepAlive>\n    <component :is=\"view\"></component>\n  </KeepAlive>\n  ```\n\n  Когда используется с `v-if` / `v-else` ветвями, одновременно должен рендериться только один компонент:\n\n  ```html\n  <KeepAlive>\n    <comp-a v-if=\"a > 1\"></comp-a>\n    <comp-b v-else></comp-b>\n  </KeepAlive>\n  ```\n\n  Использование вместе с `<Transition>`:\n\n  ```html\n  <Transition>\n    <KeepAlive>\n      <component :is=\"view\"></component>\n    </KeepAlive>\n  </Transition>\n  ```\n\n  Использование `include` / `exclude`:\n\n  ```html\n  <!-- строка, с перечислением через запятую -->\n  <KeepAlive include=\"a,b\">\n    <component :is=\"view\"></component>\n  </KeepAlive>\n\n  <!-- регулярное выражение (используется `v-bind`) -->\n  <KeepAlive :include=\"/a|b/\">\n    <component :is=\"view\"></component>\n  </KeepAlive>\n\n  <!-- массив (используется `v-bind`) -->\n  <KeepAlive :include=\"['a', 'b']\">\n    <component :is=\"view\"></component>\n  </KeepAlive>\n  ```\n\n  Использование с `max`:\n\n  ```html\n  <KeepAlive :max=\"10\">\n    <component :is=\"view\"></component>\n  </KeepAlive>\n  ```\n\n- **См. также** [Руководство — KeepAlive](https://ru.vuejs.org/guide/built-ins/keep-alive.html)\n"
      },
      "attributes": [],
      "references": "api/built-in-components.html#keepalive"
    },
    {
      "name": "Teleport",
      "description": {
        "kind": "markdown",
        "value": "\nПеремещает содержимое своего слота в другую часть DOM.\n\n- **Входные параметры**\n\n  ```ts\n  interface TeleportProps {\n    /**\n     * Обязательный. Задаёт целевой контейнер.\n     * Может быть селектором или непосредственно элементом.\n     */\n    to: string | HTMLElement\n    /**\n     * Если `true`, содержимое останется на своем первоначальном\n     * месте, вместо перемещения в целевой контейнер.\n     * Может изменяться динамически.\n     */\n    disabled?: boolean\n    /**\n     * When `true`, the Teleport will defer until other\n     * parts of the application have been mounted before\n     * resolving its target. (3.5+)\n     */\n    defer?: boolean\n  }\n  ```\n\n- **Пример**\n\n  Указание целевого контейнера:\n\n  ```html\n  <Teleport to=\"#some-id\" />\n  <Teleport to=\".some-class\" />\n  <Teleport to=\"[data-teleport]\" />\n  ```\n\n  Перемещение по условию:\n\n  ```html\n  <Teleport to=\"#popup\" :disabled=\"displayVideoInline\">\n    <video src=\"./my-movie.mp4\">\n  </Teleport>\n  ```\n\n  Defer target resolution <sup class=\"vt-badge\" data-text=\"3.5+\" />:\n\n  ```html\n  <Teleport defer to=\"#late-div\">...</Teleport>\n\n  <!-- somewhere later in the template -->\n  <div id=\"late-div\"></div>\n  ```\n\n- **См. также** [Руководство — Teleport](https://ru.vuejs.org/guide/built-ins/teleport.html)\n"
      },
      "attributes": [],
      "references": "api/built-in-components.html#teleport"
    },
    {
      "name": "Suspense",
      "description": {
        "kind": "markdown",
        "value": "\nИспользуется для оркестровки вложенных асинхронных зависимостей в дереве компонентов.\n\n- **Входные параметры**\n\n  ```ts\n  interface SuspenseProps {\n    timeout?: string | number\n    suspensible?: boolean\n  }\n  ```\n\n- **События**\n\n  - `@resolve`\n  - `@pending`\n  - `@fallback`\n\n- **Подробности**\n\n  `<Suspense>` принимает два слота: `#default` и `#fallback`. Он будет отображать содержимое `#fallback` слота во время рендеринга `#default` слота в памяти.\n\n  Если он встречает асинхронные зависимости ([Асинхронные компоненты](https://ru.vuejs.org/guide/components/async.html) и компоненты с [`async setup()`](https://ru.vuejs.org/guide/built-ins/suspense.html#async-setup)) во время рендеринга `#default` слота, он будет ждать, пока все они не будут разрешены, прежде чем отобразить `#default` слот.\n\n  Если установить для Suspense значение `suspensible`, вся обработка асинхронных зависимостей будет выполняться родительским Suspense. См. [подробности реализации](https://github.com/vuejs/core/pull/6736)\n\n- **См. также** [Руководство — Suspense](https://ru.vuejs.org/guide/built-ins/suspense.html)\n"
      },
      "attributes": [],
      "references": "api/built-in-components.html#suspense"
    },
    {
      "name": "component",
      "description": {
        "kind": "markdown",
        "value": "\n«Мета-компонент» для отрисовки динамических компонентов.\n\n- **Входные параметры**\n\n  ```ts\n  interface DynamicComponentProps {\n    is: string | Component\n  }\n  ```\n\n- **Подробности**\n\n  - Фактический компонент, который будет отображаться, определяется параметром `is`.\n\n  - Когда `is` является строкой, это может быть либо имя HTML-тега, либо зарегистрированное имя компонента.\n\n  - Кроме того, `is` может быть непосредственно связано с определением компонента.\n\n- **Пример**\n\n  Рендеринг компонентов по зарегистрированному имени (Options API):\n\n  ```vue\n  <script>\n  import Foo from './Foo.vue'\n  import Bar from './Bar.vue'\n\n  export default {\n    components: { Foo, Bar },\n    data() {\n      return {\n        view: 'Foo'\n      }\n    }\n  }\n  </script>\n\n  <template>\n    <component :is=\"view\" />\n  </template>\n  ```\n\n  Рендеринг компонентов по определению (Composition API с `<script setup>`):\n\n  ```vue\n  <script setup>\n  import Foo from './Foo.vue'\n  import Bar from './Bar.vue'\n  </script>\n\n  <template>\n    <component :is=\"Math.random() > 0.5 ? Foo : Bar\" />\n  </template>\n  ```\n\n  Рендеринг HTML-элементов:\n\n  ```html\n  <component :is=\"href ? 'a' : 'span'\"></component>\n  ```\n\n  Все [встроенные компоненты](./built-in-components) могут быть переданы в `is`, но их необходимо зарегистрировать, если хотите передать их по имени. Например:\n\n  ```vue\n  <script>\n  import { Transition, TransitionGroup } from 'vue'\n\n  export default {\n    components: {\n      Transition,\n      TransitionGroup\n    }\n  }\n  </script>\n\n  <template>\n    <component :is=\"isGroup ? 'TransitionGroup' : 'Transition'\">\n      ...\n    </component>\n  </template>\n  ```\n\n  Регистрация не требуется, если передаете сам компонент в `is`, а не его имя, например, в `<script setup>`.\n\n  Если `v-model` используется в теге `<component>`, компилятор шаблона расширит его до входного параметра `modelValue` и прослушивателя событий `update:modelValue`, как и для любого другого компонента. Однако это не будет совместимо с собственными HTML-элементами, такими как `<input>` или `<select>`. В результате использование `v-model` с динамически созданным собственным элементом не будет работать:\n\n  ```vue\n  <script setup>\n  import { ref } from 'vue'\n\n  const tag = ref('input')\n  const username = ref('')\n  </script>\n\n  <template>\n    <!-- ЭТО НЕ СРАБОТАЕТ, так как 'input' является собственным элементом HTML -->\n    <component :is=\"tag\" v-model=\"username\" />\n  </template>\n  ```\n\n  На практике этот крайний случай встречается нечасто, поскольку в реальных приложениях нативные поля форм обычно оборачиваются в компоненты. Если необходимо использовать нативный элемент напрямую, то можно разделить `v-model` на атрибут и событие вручную.\n\n- **См. также** [Динамические компоненты](https://ru.vuejs.org/guide/essentials/component-basics.html#dynamic-components)\n"
      },
      "attributes": [],
      "references": "api/built-in-special-elements.html#component"
    },
    {
      "name": "slot",
      "description": {
        "kind": "markdown",
        "value": "\nОбозначает выходы содержимого слотов в шаблонах.\n\n- **Входные параметры**\n\n  ```ts\n  interface SlotProps {\n    /**\n     * Любые входные параметры, переданные в <slot>, передаются в качестве аргументов\n     * для слотов с ограниченным пространством\n     */\n    [key: string]: any\n    /**\n     * Зарезервировано для указания имени слота.\n     */\n    name?: string\n  }\n  ```\n\n- **Подробности**\n\n  Элемент `<slot>` может использовать атрибут `name` для указания имени слота. Если `name` не указано, он отобразит слот по умолчанию. Дополнительные атрибуты, переданные элементу slot, будут переданы в качестве входного параметра слота в слот с ограниченной областью действия, определенный в родительском элементе.\n\n  Сам элемент будет заменен соответствующим содержимым слота.\n\n  Элементы `<slot>` в шаблонах Vue скомпилированы в JavaScript, поэтому их не следует путать с [собственными элементами `<slot>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot).\n\n- **См. также** [Компонент - Слоты](https://ru.vuejs.org/guide/components/slots.html)\n"
      },
      "attributes": [],
      "references": "api/built-in-special-elements.html#slot"
    },
    {
      "name": "template",
      "description": {
        "kind": "markdown",
        "value": "\nТег `<template>` используется как \"псевдоэлемент\", когда мы хотим использовать встроенную директиву без отрисовки элемента в DOM.\n\n- **Подробности**\n\n  Специальная обработка для `<template>` срабатывает только в том случае, если он используется с одной из этих директив:\n\n  - `v-if`, `v-else-if` или `v-else`\n  - `v-for`\n  - `v-slot`\n\n  Если не присутствует ни одна из этих директив, то вместо этого он будет отображаться как [нативный элемент `<template>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template).\n\n  Элемент`<template>` в связке с `v-for` также может иметь [атрибут `key`](https://ru.vuejs.org/api/built-in-special-attributes.html#key). Все остальные атрибуты и директивы будут проигнорированы, так как они не имеют смысла без соответствующего элемента.\n\n  Однофайловые компоненты используют [тег верхнего уровня `<template>`](https://ru.vuejs.org/api/sfc-spec.html#language-blocks) для оборачивания всего шаблона. Это использование отличается от описанного выше использования `<template>`. Этот тег верхнего уровня не является частью самого шаблона и не поддерживает синтаксис шаблона, например директивы.\n\n- **См. также**\n  - [Руководство - `v-if` и `<template>`](https://ru.vuejs.org/guide/essentials/conditional.html#v-if-on-template)\n  - [Руководство - `v-for` и `<template>`](https://ru.vuejs.org/guide/essentials/list.html#v-for-on-template)\n  - [Руководство - Именованные слоты](https://ru.vuejs.org/guide/components/slots.html#named-slots)\n"
      },
      "attributes": [],
      "references": "api/built-in-special-elements.html#template"
    }
  ],
  "globalAttributes": [
    {
      "name": "key",
      "description": {
        "kind": "markdown",
        "value": "Специальный атрибут `key` (ключ) в первую очередь используется как подсказка для алгоритма виртуального DOM Vue для идентификации VNodes (виртуальных узлов) при вычислении разницы между обновленным списком узлов и старым.\n\n- **Ожидает** `number | string | symbol`\n\n- **Подробности**\n\n  Без ключей Vue использует алгоритм, который минимизирует перемещение элементов и пытается изменять/переиспользовать элементы одного типа как можно больше. При использовании ключей Vue переупорядочивает элементы на основании изменения ключей, а элементы с ключами, которые уже отсутствуют, будут всегда удаляться/уничтожаться. \n\n  Потомки одного и того же общего родителя должны иметь **уникальные ключи**. Дубликаты ключей будут приводить к ошибкам рендера.\n\n  Чаще всего используется в сочетании с `v-for`:\n\n  ```html\n  <ul>\n    <li v-for=\"item in items\" :key=\"item.id\">...</li>\n  </ul>\n  ```\n\n  Также может использоваться для принудительной замены элемент/компонента вместо его переиспользования. Это может пригодиться, если вы хотите:\n\n  - Корректно вызвать хуки жизненного цикла компонента\n  - Запускать анимации перехода\n\n  Например:\n\n  ```html\n  <transition>\n    <span :key=\"text\">{{ text }}</span>\n  </transition>\n  ```\n\n  При изменении значения `text`, элемент `<span>` будет всегда заменяться, вместо обновления его содержимого, поэтому будет запускаться анимация перехода.\n\n- **См. также** [Руководство — Рендер списка - Сохранение состояния с помощью `key`](https://ru.vuejs.org/guide/essentials/list.html#maintaining-state-with-key)"
      },
      "references": "api/built-in-special-attributes.html#key"
    },
    {
      "name": "ref",
      "description": {
        "kind": "markdown",
        "value": "Означает [ссылку на элементы шаблона](https://ru.vuejs.org/guide/essentials/template-refs.html).\n\n- **Ожидает** `string | Function`\n\n- **Подробности**\n\n  Атрибут `ref` используется для регистрации ссылки на элемент или дочерний компонент.\n\n  В Options API, ссылка будет зарегистрирована в объекте компонента `this.$refs`:\n\n  ```html\n  <!-- Хранится в this.$refs.p -->\n  <p ref=\"p\">hello</p>\n  ```\n\n  В Composition API, ссылка будет храниться в ref с соответствующим именем:\n\n  ```vue\n  <script setup>\n  import { useTemplateRef } from 'vue'\n\n  const pRef = useTemplateRef('p')\n  </script>\n\n  <template>\n    <p ref=\"p\">Привет</p>\n  </template>\n  ```\n\n  При использовании на обычном DOM-элементе ссылка будет указывать на этот элемент; при использовании на дочернем компоненте ссылка будет указывать на экземпляр дочернего компонента.\n\n  В качестве альтернативы `ref` может принимать функцию, что даёт полный контроль над тем, где хранить ссылку:\n\n  ```html\n  <ChildComponent :ref=\"(el) => child = el\" />\n  ```\n\n  Важное замечание о времени регистрации ref-ссылок: поскольку эти ссылки создаются render-функцией, нужно подождать, пока компонент будет смонтирован, прежде чем обращаться к ним.\n\n  Так же свойство `this.$refs` не реактивно, поэтому не следует использовать его в шаблонах для привязки данных.\n\n- **См. также**\n  - [Руководство — Ссылки на элементы шаблона](https://ru.vuejs.org/guide/essentials/template-refs.html)\n  - [Руководство - Типизация ссылок на шаблоны](https://ru.vuejs.org/guide/typescript/composition-api.html#typing-template-refs) <sup class=\"vt-badge ts\" />\n  - [Руководство - Типизация ссылок на шаблоны компонентов](https://ru.vuejs.org/guide/typescript/composition-api.html#typing-component-template-refs) <sup class=\"vt-badge ts\" />"
      },
      "references": "api/built-in-special-attributes.html#ref"
    },
    {
      "name": "is",
      "description": {
        "kind": "markdown",
        "value": "Используется для [динамических компонентов](https://ru.vuejs.org/guide/essentials/component-basics.html#dynamic-components).\n\n- **Ожидает** `string | Component`\n\n- **Использование на нативных элементах**\n \n  - Поддерживается только в 3.1+\n\n  Когда атрибут `is` используется на нативном HTML-элементе, то он интерпретируется как [пользовательский встроенный элемент](https://html.spec.whatwg.org/multipage/custom-elements#custom-elements-customized-builtin-example). Это нативная возможность веб-платформы.\n\n  Однако есть случай использования, когда может понадобиться, чтобы Vue заменил нативный элемент на компонент Vue, как это разъясняется в [Особенности парсинга DOM-шаблона](https://ru.vuejs.org/guide/essentials/component-basics.html#dom-template-parsing-caveats). В таком случае можно добавить значению атрибута `is` префикс `vue:`, чтобы Vue вместо элемента отрисовал компонент Vue:\n\n  ```html\n  <table>\n    <tr is=\"vue:my-row-component\"></tr>\n  </table>\n  ```\n\n- **См. также**\n\n  - [Специальные встроенные элементы - `<component>`](https://ru.vuejs.org/api/built-in-special-elements.html#component)\n  - [Динамические компоненты](https://ru.vuejs.org/guide/essentials/component-basics.html#dynamic-components)"
      },
      "references": "api/built-in-special-attributes.html#is"
    },
    {
      "name": "data-allow-mismatch",
      "description": {
        "kind": "markdown",
        "value": "A special attribute that can be used to suppress [hydration mismatch](https://ru.vuejs.org/guide/scaling-up/ssr.html#hydration-mismatch) warnings.\n\n- **Example**\n\n  ```html\n  <div data-allow-mismatch=\"text\">{{ data.toLocaleString() }}</div>\n  ```\n\n  The value can limit the allowed mismatch to a specific type. Allowed values are:\n\n  - `text`\n  - `children` (only allows mismatch for direct children)\n  - `class`\n  - `style`\n  - `attribute`\n\n  If no value is provided, all types of mismatches will be allowed.\n"
      },
      "references": "api/ssr.html#data-allow-mismatch"
    }
  ]
}